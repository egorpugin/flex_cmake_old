/* flex - tool to generate fast lexical analyzers */

/*  Copyright (c) 1990 The Regents of the University of California. */
/*  All rights reserved. */

/*  This code is derived from software contributed to Berkeley by */
/*  Vern Paxson. */

/*  The United States Government has rights in this work pursuant */
/*  to contract no. DE-AC03-76SF00098 between the United States */
/*  Department of Energy and the University of California. */

/*  This file is part of flex. */

/*  Redistribution and use in source and binary forms, with or without */
/*  modification, are permitted provided that the following conditions */
/*  are met: */

/*  1. Redistributions of source code must retain the above copyright */
/*     notice, this list of conditions and the following disclaimer. */
/*  2. Redistributions in binary form must reproduce the above copyright */
/*     notice, this list of conditions and the following disclaimer in the */
/*     documentation and/or other materials provided with the distribution. */

/*  Neither the name of the University nor the names of its contributors */
/*  may be used to endorse or promote products derived from this software */
/*  without specific prior written permission. */

/*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR */
/*  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED */
/*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR */
/*  PURPOSE. */

#include "flexdef.h"

/* Take note: The buffer object is sometimes used as a String buffer (one
 * continuous string), and sometimes used as a list of strings, usually line by
 * line.
 * 
 * The type is specified in buf_init by the elt_size. If the elt_size is
 * sizeof(char), then the buffer should be treated as string buffer. If the
 * elt_size is sizeof(char*), then the buffer should be treated as a list of
 * strings.
 *
 * Certain functions are only appropriate for one type or the other. 
 */

/* global buffers. */
Buf userdef_buf;		/**< for user #definitions triggered by cmd-line. */
Buf defs_buf;		/**< for #define's autogenerated. List of strings. */
Buf yydmap_buf;		/**< string buffer to hold yydmap elements */
Buf m4defs_buf;          /**< m4 definitions. List of strings. */
Buf top_buf;             /**< contains %top code. String buffer. */

Buf *buf_print_strings(Buf * buf, FILE* out)
{
    if(!buf || !out)
        return buf;

    auto s = buf->getText();
    fprintf(out, "%s", s.c_str());
    //chain_pipe.push_to_all(s);
    return buf;
}

/* Append a "%s" formatted string to a string buffer */
Buf *buf_prints (Buf *buf, const char *fmt, const char *s)
{
	char   *t;
    size_t tsz;

	tsz = strlen(fmt) + strlen(s) + 1;
	t = (char*)malloc(tsz);
	if (!t)
	    flexfatal (_("Allocation of buffer to print string failed"));
	snprintf (t, tsz, fmt, s);
	buf = buf_strappend (buf, t);
	free(t);
	return buf;
}

/** Append a line directive to the string buffer.
 * @param buf A string buffer.
 * @param filename file name
 * @param lineno line number
 * @return buf
 */
Buf *buf_linedir (Buf *buf, const char* filename, int lineno)
{
    char *dst, *t;
    const char *src;

    t = (char*)malloc(strlen("#line \"\"\n")          +   /* constant parts */
                    2 * strlen (filename)            +   /* filename with possibly all backslashes escaped */
                    (int) (1 + log10 (abs (lineno))) +   /* line number */
                    1);                                  /* NUL */
    if (!t)
      flexfatal (_("Allocation of buffer for line directive failed"));
    for (dst = t + sprintf (t, "#line %d \"", lineno), src = filename; *src; *dst++ = *src++)
      if (*src == '\\')   /* escape backslashes */
        *dst++ = '\\';
    *dst++ = '"';
    *dst++ = '\n';
    *dst   = '\0';
    buf = buf_strappend (buf, t);
    free(t);
    return buf;
}


/** Append the contents of @a src to @a dest.
 * @param @a dest the destination buffer
 * @param @a dest the source buffer
 * @return @a dest
 */
Buf *buf_concat(Buf* dest, const Buf* src)
{
    *dest += *src;
    return dest;
}


/* Appends n characters in str to buf. */
Buf *buf_strnappend (Buf *buf, const char *str, int n)
{
    String s(str, str + n);
	buf_append (buf, s.c_str());
	return buf;
}

/* Appends characters in str to buf. */
Buf *buf_strappend (Buf *buf, const char *str)
{
	return buf_append(buf, str);
}

/* appends "#define str def\n" */
Buf *buf_strdefine (Buf *buf, const char *str, const char *def)
{
	buf_strappend (buf, "#define ");
	buf_strappend (buf, " ");
	buf_strappend (buf, str);
	buf_strappend (buf, " ");
	buf_strappend (buf, def);
	buf_strappend (buf, "\n");
	return buf;
}

/** Pushes "m4_define( [[def]], [[val]])m4_dnl" to end of buffer.
 * @param buf A buffer as a list of strings.
 * @param def The m4 symbol to define.
 * @param val The definition; may be NULL.
 * @return buf
 */
Buf *buf_m4_define (Buf *buf, const char* def, const char* val)
{
    const char * fmt = "m4_define( [[%s]], [[%s]])m4_dnl\n";
    char * str;
    size_t strsz;

    val = val?val:"";
    strsz = strlen(fmt) + strlen(def) + strlen(val) + 2;
    str = (char*)malloc(strsz);
    if (!str)
        flexfatal (_("Allocation of buffer for m4 def failed"));

    snprintf(str, strsz, fmt, def, val);
    buf_append(buf, str);
    return buf;
}

/** Pushes "m4_undefine([[def]])m4_dnl" to end of buffer.
 * @param buf A buffer as a list of strings.
 * @param def The m4 symbol to undefine.
 * @return buf
 */
Buf *buf_m4_undefine (Buf *buf, const char* def)
{
    const char * fmt = "m4_undefine( [[%s]])m4_dnl\n";
    char * str;
    size_t strsz;

    strsz = strlen(fmt) + strlen(def) + 2;
    str = (char*)malloc(strsz);
    if (!str)
        flexfatal (_("Allocation of buffer for m4 undef failed"));

    snprintf(str, strsz, fmt, def);
    buf_append(buf, str);
    return buf;
}

/* create buf with 0 elements, each of size elem_size. */
void buf_init (Buf *buf, size_t elem_size)
{
}

/* frees memory */
void buf_destroy (Buf *buf)
{
}


/* appends ptr[] to buf, grow if necessary.
 * n_elem is number of elements in ptr[], NOT bytes.
 * returns buf.
 * We grow by mod(512) boundaries.
 */

Buf *buf_append (Buf *buf, const char *ptr)
{
    if (!buf || !ptr)
        return buf;

    buf->addText(ptr);

	return buf;
}

